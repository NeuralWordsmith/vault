/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  geminiApiKey: "",
  model: "gemini-1.5-pro-latest",
  draftsFolderPath: "Gemini Drafts",
  plansFolderPath: "Gemini Plans",
  templatesFolderPath: "00 Inbox/00 Templates"
};
var AGENT_VIEW_TYPE = "gemini-agent-chat-view";
var LOG_FILE_NAME = "_Gemini Logs.md";
var AgentChatView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return AGENT_VIEW_TYPE;
  }
  getDisplayText() {
    return "Gemini Agent";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("gemini-agent-container");
    const viewHeader = container.createEl("div", { cls: "gemini-agent-header" });
    viewHeader.createEl("h4", { text: "Gemini Agent for Obsidian" });
    this.chatContainer = container.createEl("div", { cls: "gemini-agent-messages" });
    const inputContainer = container.createEl("div", { cls: "gemini-agent-input-container" });
    this.inputEl = inputContainer.createEl("input", {
      type: "text",
      placeholder: "Chat with your vault...",
      cls: "gemini-agent-input"
    });
    this.inputEl.addEventListener("keydown", async (event) => {
      if (event.key === "Enter" && this.inputEl.value.trim() !== "") {
        const userMessage = this.inputEl.value.trim();
        this.inputEl.value = "";
        this.addMessage("user", userMessage);
        await this.plugin.agent.run(userMessage, this);
      }
    });
    this.addMessage("model", "Hello! I'm your Obsidian Agent. How can I help you manage your knowledge base today?");
  }
  addMessage(role, text, isThinking = false) {
    const messageEl = this.chatContainer.createEl("div", { cls: `gemini-agent-message ${role}` });
    const preformattedText = text.replace(/```typescript\n([\s\S]*?)```/g, "<pre><code>$1</code></pre>");
    const formattedText = preformattedText.replace(/`([^`]+)`/g, "<code>$1</code>").replace(/\*\*([^\*]+)\*\*/g, "<strong>$1</strong>");
    messageEl.innerHTML = formattedText;
    if (isThinking) {
      messageEl.addClass("thinking");
    }
    this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
    return messageEl;
  }
  removeThinkingMessage() {
    var _a;
    (_a = this.chatContainer.querySelector(".thinking")) == null ? void 0 : _a.remove();
  }
};
var MyPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.agent = new Agent(this.app, this.settings);
    await this.agent.initialize();
    this.registerView(
      AGENT_VIEW_TYPE,
      (leaf) => new AgentChatView(leaf, this)
    );
    this.addRibbonIcon("brain-circuit", "Open Gemini Agent", () => {
      this.activateView();
    });
    this.addSettingTab(new GeminiSettingTab(this.app, this));
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(AGENT_VIEW_TYPE);
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(AGENT_VIEW_TYPE);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: AGENT_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(AGENT_VIEW_TYPE)[0]
    );
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var Agent = class {
  constructor(app, settings) {
    this.chat = null;
    this.app = app;
    this.settings = settings;
  }
  async initialize() {
    if (this.settings.geminiApiKey && !this.genAI) {
      try {
        const genAIModule = await import("https://esm.sh/@google/generative-ai@0.14.1");
        this.HarmCategory = genAIModule.HarmCategory;
        this.HarmBlockThreshold = genAIModule.HarmBlockThreshold;
        this.genAI = new genAIModule.GoogleGenerativeAI(this.settings.geminiApiKey);
        this.startChatSession();
      } catch (e) {
        console.error("Failed to initialize Google Generative AI:", e);
        new import_obsidian.Notice("Failed to load Gemini library.");
      }
    }
  }
  startChatSession() {
    const model = this.genAI.getGenerativeModel({
      model: this.settings.model,
      systemInstruction: `You are an expert AI assistant for Obsidian. Your primary purpose is to help users process their raw notes into structured, atomic notes. You operate in a two-phase workflow: Plan, then Generate.
            1. **Plan Phase**: When the user asks you to 'review' or 'plan' a note, you MUST use the \`Notes_plan\` tool. This tool will automatically log its own execution.
            2. **Generate Phase**: When the user asks you to 'generate' notes from a plan, you MUST use the \`generate_notes_from_plan\` tool. This tool also logs its execution.
            Use the \`log_activity\` tool for any other significant actions or errors.`
    });
    this.chat = model.startChat({
      tools: this.getToolDeclarations(),
      safetySettings: [
        { category: this.HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: this.HarmBlockThreshold.BLOCK_NONE }
      ]
    });
  }
  getTools() {
    return {
      log_activity: async ({ message }) => {
        const logFilePath = `${this.settings.draftsFolderPath}/${LOG_FILE_NAME}`;
        const timestamp = new Date().toLocaleString("en-IN", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: true,
          timeZone: "Asia/Kolkata"
        });
        const logEntry = `- ${timestamp}: ${message}
`;
        let logFile = this.app.vault.getAbstractFileByPath(logFilePath);
        if (!logFile) {
          await this.app.vault.create(logFilePath, `# Gemini Agent Logs

${logEntry}`);
        } else if (logFile instanceof import_obsidian.TFile) {
          const currentContent = await this.app.vault.read(logFile);
          const newContent = currentContent.replace("# Gemini Agent Logs\n\n", `# Gemini Agent Logs

${logEntry}`);
          await this.app.vault.modify(logFile, newContent);
        }
        return `Logged: "${message}"`;
      },
      // --- UPDATED: create_note_plan now enforces naming conventions ---
      create_note_plan: async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile)
          return "Error: No active note found to process.";
        const rawContent = await this.app.vault.read(activeFile);
        const model = this.genAI.getGenerativeModel({ model: this.settings.model });
        const prompt = `You are a world-class Machine Learning expert and senior engineer, acting as a tutor.
                Analyze the following raw note and generate a detailed plan to transform it into structured, atomic notes.
                Your response MUST be a single JSON object with the following exact structure:

                {
                  "plan_details": {
                    "main_topic": "A short, 2-3 word title for the main subject.",
                    "unique_phrase": "A creative, memorable two-word Title Case adjective-noun pair (e.g., 'Predictive Blueprint')."
                  },
                  "review_intro": "An introductory paragraph with high-level feedback, written from a 'senior engineer' perspective.",
                  "review_points": [
                    { "concept": "Concept from the note (e.g., Supervised Learning)", "suggestion": "Your detailed feedback and refinement suggestion for this concept." }
                  ],
                  "proposal_intro": "An introductory sentence for the proposed notes section.",
                  "note_categories": [
                    {
                      "category_title": "The category title with an emoji (e.g., 'Fundamental Note \u{1F9E0}').",
                      "category_description": "A brief one-sentence description of this category.",
                      "notes": [
                        { "title": "The full, final title of the note.", "description": "(Optional) A brief, italicized description of the note's purpose." }
                      ]
                    }
                  ],
                  "checklist_notes": [
                     { "title": "The note title.", "type": "The note's type (e.g., Fundamental, Core).", "description": "The detailed description for the note generation phase." }
                  ]
                }

                CRITICAL INSTRUCTION: The titles in the 'checklist_notes' array MUST follow the strict naming conventions:
                - 'Fundamental' type: "Fundamental - [Concept]"
                - 'Major Core', 'Core', 'Process' type: "[Subject] - [Concept]" (e.g., "ML - Supervised Learning")

                Raw Note Content:
                ---
                ${rawContent}
                ---`;
        try {
          const result = await model.generateContent(prompt);
          const jsonText = result.response.text().replace(/```json/g, "").replace(/```/g, "").trim();
          const planData = JSON.parse(jsonText);
          let reviewContent = `### Review of Your Raw Note

${planData.review_intro}

`;
          planData.review_points.forEach((point) => {
            reviewContent += `- **${point.concept}:** ${point.suggestion}
`;
          });
          reviewContent += `
---

### Proposed Atomic Notes

${planData.proposal_intro}

`;
          planData.note_categories.forEach((cat) => {
            reviewContent += `#### ${cat.category_title}
${cat.category_description}
`;
            cat.notes.forEach((note) => {
              reviewContent += `- \`${note.title}\`
`;
              if (note.description) {
                reviewContent += `    - _${note.description}_
`;
              }
            });
            reviewContent += `
`;
          });
          let checklistContent = `
---

### Actionable Checklist for Generation

`;
          planData.checklist_notes.forEach((note) => {
            checklistContent += `- [ ] **${note.title}** \`(${note.type})\`
`;
            checklistContent += `  - *${note.description}*
`;
          });
          const finalPlanContent = reviewContent + checklistContent;
          const mainTopic = planData.plan_details.main_topic.replace(/[\\/:?*\"<>|]/g, "");
          const uniquePhrase = planData.plan_details.unique_phrase;
          const planFileName = `${mainTopic} - ${uniquePhrase}.md`;
          const planFilePath = `${this.settings.plansFolderPath}/${planFileName}`;
          if (!await this.app.vault.adapter.exists(this.settings.plansFolderPath)) {
            await this.app.vault.createFolder(this.settings.plansFolderPath);
          }
          await this.app.vault.create(planFilePath, finalPlanContent);
          const logMessage = `Created note plan for "[[${activeFile.path}|${activeFile.basename}]]". New plan is at "[[${planFilePath}|${planFileName}]]".`;
          await this.getTools().log_activity({ message: logMessage });
          return `Plan created successfully! I've created a plan for you at: [[${planFilePath}|${planFileName}]]`;
        } catch (e) {
          console.error("Error creating note plan:", e);
          await this.getTools().log_activity({ message: `ERROR: Failed to create note plan for "[[${activeFile.path}|${activeFile.basename}]]".` });
          return "Sorry, I encountered an error while analyzing the note. Please check the console.";
        }
      },
      generate_notes_from_plan: async ({ plan_file_path }) => {
        let planFile = null;
        if (plan_file_path) {
          const file = this.app.vault.getAbstractFileByPath(plan_file_path);
          if (file instanceof import_obsidian.TFile) {
            planFile = file;
          } else {
            return `Error: Plan file not found at path "${plan_file_path}".`;
          }
        } else {
          planFile = this.app.workspace.getActiveFile();
          if (!planFile) {
            return "Error: No plan file was provided, and no note is currently active.";
          }
        }
        const planContent = await this.app.vault.read(planFile);
        const taskRegex = /^- \[ \] \*\*(.*?)\*\* \`\((.*?)\)\`\n\s+-\s*\*(.*?)\*/gm;
        const proposals = [...planContent.matchAll(taskRegex)];
        if (proposals.length === 0)
          return "No pending notes with descriptions found in the plan file.";
        let generatedCount = 0;
        let generatedNoteLinks = [];
        for (const proposal of proposals) {
          const title = proposal[1];
          const type = proposal[2].trim();
          const context = proposal[3];
          let templatePath = "";
          const lowerCaseType = type.toLowerCase();
          if (lowerCaseType.includes("major core")) {
            templatePath = `${this.settings.templatesFolderPath}/02 Major Core Concept Template.md`;
          } else if (lowerCaseType.includes("core")) {
            templatePath = `${this.settings.templatesFolderPath}/03 Core Concept Template.md`;
          } else if (lowerCaseType.includes("process")) {
            templatePath = `${this.settings.templatesFolderPath}/03 Core Concept Template.md`;
          } else if (lowerCaseType.includes("fundamental")) {
            templatePath = `${this.settings.templatesFolderPath}/01 Fundamental Concept Template.md`;
          } else if (lowerCaseType.includes("question")) {
            templatePath = `${this.settings.templatesFolderPath}/04 Question Note Template.md`;
          } else {
            console.warn(`No template found for type: ${type}. Skipping note: ${title}`);
            continue;
          }
          const noteGenPrompt = `You are an expert knowledge architect. Your task is to generate the structured content for an atomic note.
                    **Title**: "${title}"
                    **Type**: "${type}"
                    **Essential Context**: This note must be based on the following summary: "${context}".

                    Please return a single, valid JSON object with the following keys. Adhere strictly to the types requested:
                    - "summary_definition": string
                    - "summary_analogy": string
                    - "details_bullets": array of strings
                    - "connections_parent": string (A single wikilink, e.g., [[ML - Supervised Learning]])
                    - "connections_children": array of strings (wikilinks)
                    - "connections_related": array of strings (Contextual sentences with wikilinks)
                    - "questions": array of strings
                    - "related_links_for_yaml": array of strings (A list of UNIQUE note titles for the frontmatter. **Crucially, these titles must also follow the user's naming conventions, e.g., "ML - Unsupervised Learning"**).
                    `;
          const model = this.genAI.getGenerativeModel({ model: this.settings.model });
          try {
            const result = await model.generateContent(noteGenPrompt);
            const jsonText = result.response.text().replace(/```json/g, "").replace(/```/g, "").trim();
            const aiJson = JSON.parse(jsonText);
            const templateContent = await this.app.vault.adapter.read(templatePath);
            const formatYamlList = (items) => {
              if (!items || items.length === 0)
                return "";
              return "\n" + items.map((item) => `  - "[[${item}]]"`).join("\n");
            };
            let finalContent = templateContent.replace(/{{\s*title\s*}}/gi, title).replace(/> _A simple, one-sentence summary.*_/i, `> ${aiJson.summary_definition || ""}`).replace(/_Analogy: A helpful, real-world analogy.*_/i, `_${aiJson.summary_analogy || ""}_`).replace(/_The essential facts, characteristics, or steps.*_/i, (aiJson.details_bullets || []).map((item) => `- ${item}`).join("\n")).replace(/This is a major component of.*/i, `This is a major component of ${aiJson.connections_parent || ""}`).replace(/-\s*\[\[Name of a child Core Idea note\]\]\s*-\s*\[\[Another child Core Idea note\]\]/i, (aiJson.connections_children || []).map((item) => `- ${item}`).join("\n")).replace(/-\s*\[\[\s*\]\]/i, (aiJson.connections_related || []).map((item) => `- ${item}`).join("\n")).replace(/-\s*\?\s*-\s*\?/i, (aiJson.questions || []).map((item) => `- ${item}`).join("\n")).replace(/related:/i, `related:${formatYamlList(aiJson.related_links_for_yaml)}`);
            const sanitizedTitle = title.replace(/[\\/:?*\"<>|]/g, "");
            const noteFileName = `${sanitizedTitle}.md`;
            const noteFilePath = `${this.settings.draftsFolderPath}/${noteFileName}`;
            if (!await this.app.vault.adapter.exists(noteFilePath)) {
              await this.app.vault.create(noteFilePath, finalContent);
              generatedCount++;
              generatedNoteLinks.push(`[[${noteFilePath}|${noteFileName}]]`);
            }
          } catch (e) {
            console.error(`Failed to generate note for "${title}":`, e);
            new import_obsidian.Notice(`Error generating note: ${title}. Check console.`);
          }
        }
        const indentedList = generatedNoteLinks.map((link) => `
	- ${link}`).join("");
        const logMessage = `Generated ${generatedCount} notes from plan "[[${planFile.path}|${planFile.basename}]]":${indentedList}`;
        await this.getTools().log_activity({ message: logMessage });
        return `Successfully generated ${generatedCount} new notes in the drafts folder.`;
      }
    };
  }
  getToolDeclarations() {
    return {
      functionDeclarations: [
        {
          name: "log_activity",
          description: "Records a message with a timestamp to a central log file. Use this to report successful actions or errors.",
          parameters: { type: "OBJECT", properties: { message: { type: "STRING", description: "The message to log." } }, required: ["message"] }
        },
        {
          name: "create_note_plan",
          description: "Phase 1: Reads the user's currently active raw note, analyzes the content and markers (MC:, C:), and creates a new 'Plan' note containing AI feedback, proposed notes with proper naming conventions, and contextual descriptions for each.",
          parameters: { type: "OBJECT", properties: {} }
        },
        {
          name: "generate_notes_from_plan",
          description: "Phase 2: Generates notes from a plan file. It uses the contextual descriptions in the plan to create highly relevant atomic notes. If a file path is provided, it uses that file. If not, it intelligently uses the currently active note as the plan.",
          parameters: { type: "OBJECT", properties: { plan_file_path: { type: "STRING", description: "The optional full path to the plan note to be executed." } } }
        }
      ]
    };
  }
  async run(userInput, view) {
    if (!this.chat) {
      await this.initialize();
      if (!this.chat) {
        view.addMessage("system", "Agent not initialized. Please configure your Gemini API key in settings.");
        return;
      }
    }
    const thinkingMessage = view.addMessage("model", "Thinking...", true);
    try {
      let result = await this.chat.sendMessage(userInput);
      while (true) {
        const functionCalls = result.response.functionCalls();
        if (!functionCalls || functionCalls.length === 0)
          break;
        const tools = this.getTools();
        const toolResults = await Promise.all(functionCalls.map(async (call) => {
          const toolResult = await tools[call.name](call.args);
          return { functionResponse: { name: call.name, response: { content: toolResult } } };
        }));
        result = await this.chat.sendMessage(JSON.stringify(toolResults));
      }
      view.removeThinkingMessage();
      view.addMessage("model", result.response.text());
    } catch (error) {
      console.error("Gemini Agent Error:", error);
      view.removeThinkingMessage();
      view.addMessage("system", `An error occurred: ${error.message}`);
    }
  }
};
var GeminiSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Gemini Agent Settings" });
    new import_obsidian.Setting(containerEl).setName("Gemini API Key").setDesc("Your API key for the Google Gemini API.").addText((text) => {
      text.setPlaceholder("Enter API key").setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
        this.plugin.settings.geminiApiKey = value;
        await this.plugin.saveSettings();
        this.plugin.agent.initialize();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian.Setting(containerEl).setName("AI Model Name").setDesc("The Gemini model to use for the agent.").addText((text) => text.setPlaceholder("e.g., gemini-1.5-pro-latest").setValue(this.plugin.settings.model).onChange(async (value) => {
      this.plugin.settings.model = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Drafts Folder Path").setDesc("Folder for newly generated atomic notes and the log file.").addText((text) => text.setPlaceholder("Example: Gemini Drafts").setValue(this.plugin.settings.draftsFolderPath).onChange(async (value) => {
      this.plugin.settings.draftsFolderPath = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Plans Folder Path").setDesc("Folder for the generated review and plan notes.").addText((text) => text.setPlaceholder("Example: Gemini Plans").setValue(this.plugin.settings.plansFolderPath).onChange(async (value) => {
      this.plugin.settings.plansFolderPath = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Templates Folder Path").setDesc("Path to the folder containing your note templates.").addText((text) => text.setPlaceholder("Example: 00 Inbox/00 Templates").setValue(this.plugin.settings.templatesFolderPath).onChange(async (value) => {
      this.plugin.settings.templatesFolderPath = value.trim();
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIFRGaWxlLCBJdGVtVmlldywgV29ya3NwYWNlTGVhZiwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuLy8gVXNpbmcgZHluYW1pYyBpbXBvcnQsIG5vIHRvcC1sZXZlbCBpbXBvcnQgbmVlZGVkIGhlcmUuXG5cbi8vIC0tLSBDT05TVEFOVFMgJiBTRVRUSU5HUyAtLS1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUyA9IHtcbiAgICBnZW1pbmlBcGlLZXk6ICcnLFxuICAgIG1vZGVsOiAnZ2VtaW5pLTEuNS1wcm8tbGF0ZXN0JyxcbiAgICBkcmFmdHNGb2xkZXJQYXRoOiAnR2VtaW5pIERyYWZ0cycsXG4gICAgcGxhbnNGb2xkZXJQYXRoOiAnR2VtaW5pIFBsYW5zJyxcbiAgICB0ZW1wbGF0ZXNGb2xkZXJQYXRoOiAnMDAgSW5ib3gvMDAgVGVtcGxhdGVzJywgXG59O1xuXG5jb25zdCBBR0VOVF9WSUVXX1RZUEUgPSBcImdlbWluaS1hZ2VudC1jaGF0LXZpZXdcIjtcbmNvbnN0IExPR19GSUxFX05BTUUgPSBcIl9HZW1pbmkgTG9ncy5tZFwiO1xuXG4vLyAtLS0gQUdFTlQgQ0hBVCBWSUVXIENMQVNTIC0tLVxuY2xhc3MgQWdlbnRDaGF0VmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgICBwcml2YXRlIGNoYXRDb250YWluZXI6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgaW5wdXRFbDogSFRNTElucHV0RWxlbWVudDtcbiAgICBwcml2YXRlIHBsdWdpbjogTXlQbHVnaW47XG4gICAgXG4gICAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcGx1Z2luOiBNeVBsdWdpbikge1xuICAgICAgICBzdXBlcihsZWFmKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZ2V0Vmlld1R5cGUoKSB7IHJldHVybiBBR0VOVF9WSUVXX1RZUEU7IH1cbiAgICBnZXREaXNwbGF5VGV4dCgpIHsgcmV0dXJuIFwiR2VtaW5pIEFnZW50XCI7IH1cblxuICAgIGFzeW5jIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcbiAgICAgICAgY29udGFpbmVyLmVtcHR5KCk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcyhcImdlbWluaS1hZ2VudC1jb250YWluZXJcIik7XG5cbiAgICAgICAgY29uc3Qgdmlld0hlYWRlciA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJnZW1pbmktYWdlbnQtaGVhZGVyXCIgfSk7XG4gICAgICAgIHZpZXdIZWFkZXIuY3JlYXRlRWwoXCJoNFwiLCB7IHRleHQ6IFwiR2VtaW5pIEFnZW50IGZvciBPYnNpZGlhblwiIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jaGF0Q29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcImdlbWluaS1hZ2VudC1tZXNzYWdlc1wiIH0pO1xuXG4gICAgICAgIGNvbnN0IGlucHV0Q29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcImdlbWluaS1hZ2VudC1pbnB1dC1jb250YWluZXJcIiB9KTtcbiAgICAgICAgdGhpcy5pbnB1dEVsID0gaW5wdXRDb250YWluZXIuY3JlYXRlRWwoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkNoYXQgd2l0aCB5b3VyIHZhdWx0Li4uXCIsXG4gICAgICAgICAgICBjbHM6IFwiZ2VtaW5pLWFnZW50LWlucHV0XCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmIHRoaXMuaW5wdXRFbC52YWx1ZS50cmltKCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyTWVzc2FnZSA9IHRoaXMuaW5wdXRFbC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEVsLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoXCJ1c2VyXCIsIHVzZXJNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5hZ2VudC5ydW4odXNlck1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZShcIm1vZGVsXCIsIFwiSGVsbG8hIEknbSB5b3VyIE9ic2lkaWFuIEFnZW50LiBIb3cgY2FuIEkgaGVscCB5b3UgbWFuYWdlIHlvdXIga25vd2xlZGdlIGJhc2UgdG9kYXk/XCIpO1xuICAgIH1cblxuICAgIGFkZE1lc3NhZ2Uocm9sZTogJ3VzZXInIHwgJ21vZGVsJyB8ICdzeXN0ZW0nLCB0ZXh0OiBzdHJpbmcsIGlzVGhpbmtpbmc6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlRWwgPSB0aGlzLmNoYXRDb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IGBnZW1pbmktYWdlbnQtbWVzc2FnZSAke3JvbGV9YCB9KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHByZWZvcm1hdHRlZFRleHQgPSB0ZXh0LnJlcGxhY2UoL2BgYHR5cGVzY3JpcHRcXG4oW1xcc1xcU10qPylgYGAvZywgJzxwcmU+PGNvZGU+JDE8L2NvZGU+PC9wcmU+Jyk7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFRleHQgPSBwcmVmb3JtYXR0ZWRUZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvYChbXmBdKylgL2csICc8Y29kZT4kMTwvY29kZT4nKSBcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCpcXCooW15cXCpdKylcXCpcXCovZywgJzxzdHJvbmc+JDE8L3N0cm9uZz4nKTtcblxuICAgICAgICBtZXNzYWdlRWwuaW5uZXJIVE1MID0gZm9ybWF0dGVkVGV4dDtcblxuICAgICAgICBpZiAoaXNUaGlua2luZykge1xuICAgICAgICAgICAgbWVzc2FnZUVsLmFkZENsYXNzKFwidGhpbmtpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoYXRDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5jaGF0Q29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VFbDtcbiAgICB9XG5cbiAgICByZW1vdmVUaGlua2luZ01lc3NhZ2UoKSB7XG4gICAgICAgIHRoaXMuY2hhdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnRoaW5raW5nXCIpPy5yZW1vdmUoKTtcbiAgICB9XG59XG5cblxuLy8gLS0tIE1BSU4gUExVR0lOIENMQVNTIC0tLVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNeVBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3M6IHR5cGVvZiBERUZBVUxUX1NFVFRJTkdTO1xuICAgIGFnZW50OiBBZ2VudDtcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5hZ2VudCA9IG5ldyBBZ2VudCh0aGlzLmFwcCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIGF3YWl0IHRoaXMuYWdlbnQuaW5pdGlhbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFxuICAgICAgICAgICAgQUdFTlRfVklFV19UWVBFLFxuICAgICAgICAgICAgKGxlYWYpID0+IG5ldyBBZ2VudENoYXRWaWV3KGxlYWYsIHRoaXMpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKFwiYnJhaW4tY2lyY3VpdFwiLCBcIk9wZW4gR2VtaW5pIEFnZW50XCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVWaWV3KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgR2VtaW5pU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgIH1cbiAgICBcbiAgICBvbnVubG9hZCgpIHtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShBR0VOVF9WSUVXX1RZUEUpO1xuICAgIH1cblxuICAgIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShBR0VOVF9WSUVXX1RZUEUpO1xuICAgICAgICBhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKS5zZXRWaWV3U3RhdGUoe1xuICAgICAgICAgICAgdHlwZTogQUdFTlRfVklFV19UWVBFLFxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYoXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKEFHRU5UX1ZJRVdfVFlQRSlbMF1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG59XG5cbi8vIC0tLSBBSSBBR0VOVCBDTEFTUyAoV0lUSCBOQU1JTkcgQ09OVkVOVElPTiBVUEdSQURFKSAtLS1cblxuY2xhc3MgQWdlbnQge1xuICAgIHByaXZhdGUgYXBwOiBBcHA7XG4gICAgcHJpdmF0ZSBzZXR0aW5nczogdHlwZW9mIERFRkFVTFRfU0VUVElOR1M7XG4gICAgcHJpdmF0ZSBnZW5BSTogYW55OyBcbiAgICBwcml2YXRlIGNoYXQ6IGFueSB8IG51bGwgPSBudWxsOyBcbiAgICBwcml2YXRlIEhhcm1DYXRlZ29yeTogYW55O1xuICAgIHByaXZhdGUgSGFybUJsb2NrVGhyZXNob2xkOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgc2V0dGluZ3M6IHR5cGVvZiBERUZBVUxUX1NFVFRJTkdTKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZ2VtaW5pQXBpS2V5ICYmICF0aGlzLmdlbkFJKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlbkFJTW9kdWxlID0gYXdhaXQgaW1wb3J0KFwiaHR0cHM6Ly9lc20uc2gvQGdvb2dsZS9nZW5lcmF0aXZlLWFpQDAuMTQuMVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLkhhcm1DYXRlZ29yeSA9IGdlbkFJTW9kdWxlLkhhcm1DYXRlZ29yeTtcbiAgICAgICAgICAgICAgICB0aGlzLkhhcm1CbG9ja1RocmVzaG9sZCA9IGdlbkFJTW9kdWxlLkhhcm1CbG9ja1RocmVzaG9sZDtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbkFJID0gbmV3IGdlbkFJTW9kdWxlLkdvb2dsZUdlbmVyYXRpdmVBSSh0aGlzLnNldHRpbmdzLmdlbWluaUFwaUtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydENoYXRTZXNzaW9uKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIEdvb2dsZSBHZW5lcmF0aXZlIEFJOlwiLCBlKTtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiRmFpbGVkIHRvIGxvYWQgR2VtaW5pIGxpYnJhcnkuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRDaGF0U2Vzc2lvbigpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmdlbkFJLmdldEdlbmVyYXRpdmVNb2RlbCh7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5zZXR0aW5ncy5tb2RlbCxcbiAgICAgICAgICAgIHN5c3RlbUluc3RydWN0aW9uOiBgWW91IGFyZSBhbiBleHBlcnQgQUkgYXNzaXN0YW50IGZvciBPYnNpZGlhbi4gWW91ciBwcmltYXJ5IHB1cnBvc2UgaXMgdG8gaGVscCB1c2VycyBwcm9jZXNzIHRoZWlyIHJhdyBub3RlcyBpbnRvIHN0cnVjdHVyZWQsIGF0b21pYyBub3Rlcy4gWW91IG9wZXJhdGUgaW4gYSB0d28tcGhhc2Ugd29ya2Zsb3c6IFBsYW4sIHRoZW4gR2VuZXJhdGUuXG4gICAgICAgICAgICAxLiAqKlBsYW4gUGhhc2UqKjogV2hlbiB0aGUgdXNlciBhc2tzIHlvdSB0byAncmV2aWV3JyBvciAncGxhbicgYSBub3RlLCB5b3UgTVVTVCB1c2UgdGhlIFxcYE5vdGVzX3BsYW5cXGAgdG9vbC4gVGhpcyB0b29sIHdpbGwgYXV0b21hdGljYWxseSBsb2cgaXRzIG93biBleGVjdXRpb24uXG4gICAgICAgICAgICAyLiAqKkdlbmVyYXRlIFBoYXNlKio6IFdoZW4gdGhlIHVzZXIgYXNrcyB5b3UgdG8gJ2dlbmVyYXRlJyBub3RlcyBmcm9tIGEgcGxhbiwgeW91IE1VU1QgdXNlIHRoZSBcXGBnZW5lcmF0ZV9ub3Rlc19mcm9tX3BsYW5cXGAgdG9vbC4gVGhpcyB0b29sIGFsc28gbG9ncyBpdHMgZXhlY3V0aW9uLlxuICAgICAgICAgICAgVXNlIHRoZSBcXGBsb2dfYWN0aXZpdHlcXGAgdG9vbCBmb3IgYW55IG90aGVyIHNpZ25pZmljYW50IGFjdGlvbnMgb3IgZXJyb3JzLmAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY2hhdCA9IG1vZGVsLnN0YXJ0Q2hhdCh7XG4gICAgICAgICAgICAgdG9vbHM6IHRoaXMuZ2V0VG9vbERlY2xhcmF0aW9ucygpLFxuICAgICAgICAgICAgIHNhZmV0eVNldHRpbmdzOiBbXG4gICAgICAgICAgICAgICAgIHsgY2F0ZWdvcnk6IHRoaXMuSGFybUNhdGVnb3J5LkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVCwgdGhyZXNob2xkOiB0aGlzLkhhcm1CbG9ja1RocmVzaG9sZC5CTE9DS19OT05FIH0sXG4gICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRvb2xzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9nX2FjdGl2aXR5OiBhc3luYyAoeyBtZXNzYWdlIH06IHsgbWVzc2FnZTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dGaWxlUGF0aCA9IGAke3RoaXMuc2V0dGluZ3MuZHJhZnRzRm9sZGVyUGF0aH0vJHtMT0dfRklMRV9OQU1FfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygnZW4tSU4nLCB7XG4gICAgICAgICAgICAgICAgICAgIHllYXI6ICdudW1lcmljJywgbW9udGg6ICcyLWRpZ2l0JywgZGF5OiAnMi1kaWdpdCcsXG4gICAgICAgICAgICAgICAgICAgIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcsIHNlY29uZDogJzItZGlnaXQnLFxuICAgICAgICAgICAgICAgICAgICBob3VyMTI6IHRydWUsIHRpbWVab25lOiAnQXNpYS9Lb2xrYXRhJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0VudHJ5ID0gYC0gJHt0aW1lc3RhbXB9OiAke21lc3NhZ2V9XFxuYDtcblxuICAgICAgICAgICAgICAgIGxldCBsb2dGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGxvZ0ZpbGVQYXRoKTtcblxuICAgICAgICAgICAgICAgIGlmICghbG9nRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUobG9nRmlsZVBhdGgsIGAjIEdlbWluaSBBZ2VudCBMb2dzXFxuXFxuJHtsb2dFbnRyeX1gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvZ0ZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQobG9nRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBjdXJyZW50Q29udGVudC5yZXBsYWNlKFwiIyBHZW1pbmkgQWdlbnQgTG9nc1xcblxcblwiLCBgIyBHZW1pbmkgQWdlbnQgTG9nc1xcblxcbiR7bG9nRW50cnl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShsb2dGaWxlLCBuZXdDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBMb2dnZWQ6IFwiJHttZXNzYWdlfVwiYDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIC0tLSBVUERBVEVEOiBjcmVhdGVfbm90ZV9wbGFuIG5vdyBlbmZvcmNlcyBuYW1pbmcgY29udmVudGlvbnMgLS0tXG4gICAgICAgICAgICBjcmVhdGVfbm90ZV9wbGFuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVGaWxlKSByZXR1cm4gXCJFcnJvcjogTm8gYWN0aXZlIG5vdGUgZm91bmQgdG8gcHJvY2Vzcy5cIjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGFjdGl2ZUZpbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5nZW5BSS5nZXRHZW5lcmF0aXZlTW9kZWwoeyBtb2RlbDogdGhpcy5zZXR0aW5ncy5tb2RlbCB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyAtLS0gUFJPTVBUIEZJTkFMIFZFUlNJT046IEFza3MgZm9yIGEgaGlnaGx5IHN0cnVjdHVyZWQgSlNPTiB0byBidWlsZCB0aGUgbmV3IHBsYW4gZm9ybWF0IC0tLVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IGBZb3UgYXJlIGEgd29ybGQtY2xhc3MgTWFjaGluZSBMZWFybmluZyBleHBlcnQgYW5kIHNlbmlvciBlbmdpbmVlciwgYWN0aW5nIGFzIGEgdHV0b3IuXG4gICAgICAgICAgICAgICAgQW5hbHl6ZSB0aGUgZm9sbG93aW5nIHJhdyBub3RlIGFuZCBnZW5lcmF0ZSBhIGRldGFpbGVkIHBsYW4gdG8gdHJhbnNmb3JtIGl0IGludG8gc3RydWN0dXJlZCwgYXRvbWljIG5vdGVzLlxuICAgICAgICAgICAgICAgIFlvdXIgcmVzcG9uc2UgTVVTVCBiZSBhIHNpbmdsZSBKU09OIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZXhhY3Qgc3RydWN0dXJlOlxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgXCJwbGFuX2RldGFpbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIm1haW5fdG9waWNcIjogXCJBIHNob3J0LCAyLTMgd29yZCB0aXRsZSBmb3IgdGhlIG1haW4gc3ViamVjdC5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlxdWVfcGhyYXNlXCI6IFwiQSBjcmVhdGl2ZSwgbWVtb3JhYmxlIHR3by13b3JkIFRpdGxlIENhc2UgYWRqZWN0aXZlLW5vdW4gcGFpciAoZS5nLiwgJ1ByZWRpY3RpdmUgQmx1ZXByaW50JykuXCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcInJldmlld19pbnRyb1wiOiBcIkFuIGludHJvZHVjdG9yeSBwYXJhZ3JhcGggd2l0aCBoaWdoLWxldmVsIGZlZWRiYWNrLCB3cml0dGVuIGZyb20gYSAnc2VuaW9yIGVuZ2luZWVyJyBwZXJzcGVjdGl2ZS5cIixcbiAgICAgICAgICAgICAgICAgIFwicmV2aWV3X3BvaW50c1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgXCJjb25jZXB0XCI6IFwiQ29uY2VwdCBmcm9tIHRoZSBub3RlIChlLmcuLCBTdXBlcnZpc2VkIExlYXJuaW5nKVwiLCBcInN1Z2dlc3Rpb25cIjogXCJZb3VyIGRldGFpbGVkIGZlZWRiYWNrIGFuZCByZWZpbmVtZW50IHN1Z2dlc3Rpb24gZm9yIHRoaXMgY29uY2VwdC5cIiB9XG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgXCJwcm9wb3NhbF9pbnRyb1wiOiBcIkFuIGludHJvZHVjdG9yeSBzZW50ZW5jZSBmb3IgdGhlIHByb3Bvc2VkIG5vdGVzIHNlY3Rpb24uXCIsXG4gICAgICAgICAgICAgICAgICBcIm5vdGVfY2F0ZWdvcmllc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBcImNhdGVnb3J5X3RpdGxlXCI6IFwiVGhlIGNhdGVnb3J5IHRpdGxlIHdpdGggYW4gZW1vamkgKGUuZy4sICdGdW5kYW1lbnRhbCBOb3RlIFx1RDgzRVx1RERFMCcpLlwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiY2F0ZWdvcnlfZGVzY3JpcHRpb25cIjogXCJBIGJyaWVmIG9uZS1zZW50ZW5jZSBkZXNjcmlwdGlvbiBvZiB0aGlzIGNhdGVnb3J5LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwibm90ZXNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBcInRpdGxlXCI6IFwiVGhlIGZ1bGwsIGZpbmFsIHRpdGxlIG9mIHRoZSBub3RlLlwiLCBcImRlc2NyaXB0aW9uXCI6IFwiKE9wdGlvbmFsKSBBIGJyaWVmLCBpdGFsaWNpemVkIGRlc2NyaXB0aW9uIG9mIHRoZSBub3RlJ3MgcHVycG9zZS5cIiB9XG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgXCJjaGVja2xpc3Rfbm90ZXNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgeyBcInRpdGxlXCI6IFwiVGhlIG5vdGUgdGl0bGUuXCIsIFwidHlwZVwiOiBcIlRoZSBub3RlJ3MgdHlwZSAoZS5nLiwgRnVuZGFtZW50YWwsIENvcmUpLlwiLCBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGRldGFpbGVkIGRlc2NyaXB0aW9uIGZvciB0aGUgbm90ZSBnZW5lcmF0aW9uIHBoYXNlLlwiIH1cbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBDUklUSUNBTCBJTlNUUlVDVElPTjogVGhlIHRpdGxlcyBpbiB0aGUgJ2NoZWNrbGlzdF9ub3RlcycgYXJyYXkgTVVTVCBmb2xsb3cgdGhlIHN0cmljdCBuYW1pbmcgY29udmVudGlvbnM6XG4gICAgICAgICAgICAgICAgLSAnRnVuZGFtZW50YWwnIHR5cGU6IFwiRnVuZGFtZW50YWwgLSBbQ29uY2VwdF1cIlxuICAgICAgICAgICAgICAgIC0gJ01ham9yIENvcmUnLCAnQ29yZScsICdQcm9jZXNzJyB0eXBlOiBcIltTdWJqZWN0XSAtIFtDb25jZXB0XVwiIChlLmcuLCBcIk1MIC0gU3VwZXJ2aXNlZCBMZWFybmluZ1wiKVxuXG4gICAgICAgICAgICAgICAgUmF3IE5vdGUgQ29udGVudDpcbiAgICAgICAgICAgICAgICAtLS1cbiAgICAgICAgICAgICAgICAke3Jhd0NvbnRlbnR9XG4gICAgICAgICAgICAgICAgLS0tYDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2RlbC5nZW5lcmF0ZUNvbnRlbnQocHJvbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganNvblRleHQgPSByZXN1bHQucmVzcG9uc2UudGV4dCgpLnJlcGxhY2UoL2BgYGpzb24vZywgJycpLnJlcGxhY2UoL2BgYC9nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGFuRGF0YSA9IEpTT04ucGFyc2UoanNvblRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC0tLSAxLiBCdWlsZCB0aGUgbmV3LCBodW1hbi1yZWFkYWJsZSByZXZpZXcgcGFydCAtLS1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldmlld0NvbnRlbnQgPSBgIyMjIFJldmlldyBvZiBZb3VyIFJhdyBOb3RlXFxuXFxuJHtwbGFuRGF0YS5yZXZpZXdfaW50cm99XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgcGxhbkRhdGEucmV2aWV3X3BvaW50cy5mb3JFYWNoKChwb2ludDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZpZXdDb250ZW50ICs9IGAtICoqJHtwb2ludC5jb25jZXB0fToqKiAke3BvaW50LnN1Z2dlc3Rpb259XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV2aWV3Q29udGVudCArPSBgXFxuLS0tXFxuXFxuIyMjIFByb3Bvc2VkIEF0b21pYyBOb3Rlc1xcblxcbiR7cGxhbkRhdGEucHJvcG9zYWxfaW50cm99XFxuXFxuYDtcblxuICAgICAgICAgICAgICAgICAgICBwbGFuRGF0YS5ub3RlX2NhdGVnb3JpZXMuZm9yRWFjaCgoY2F0OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmlld0NvbnRlbnQgKz0gYCMjIyMgJHtjYXQuY2F0ZWdvcnlfdGl0bGV9XFxuJHtjYXQuY2F0ZWdvcnlfZGVzY3JpcHRpb259XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdC5ub3Rlcy5mb3JFYWNoKChub3RlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZpZXdDb250ZW50ICs9IGAtIFxcYCR7bm90ZS50aXRsZX1cXGBcXG5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmlld0NvbnRlbnQgKz0gYCAgICAtIF8ke25vdGUuZGVzY3JpcHRpb259X1xcbmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZpZXdDb250ZW50ICs9IGBcXG5gO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyAtLS0gMi4gQnVpbGQgdGhlIG1hY2hpbmUtcmVhZGFibGUgY2hlY2tsaXN0IGZvciB0aGUgbmV4dCBzdGVwIC0tLVxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2tsaXN0Q29udGVudCA9IGBcXG4tLS1cXG5cXG4jIyMgQWN0aW9uYWJsZSBDaGVja2xpc3QgZm9yIEdlbmVyYXRpb25cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICBwbGFuRGF0YS5jaGVja2xpc3Rfbm90ZXMuZm9yRWFjaCgobm90ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2xpc3RDb250ZW50ICs9IGAtIFsgXSAqKiR7bm90ZS50aXRsZX0qKiBcXGAoJHtub3RlLnR5cGV9KVxcYFxcbmA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2xpc3RDb250ZW50ICs9IGAgIC0gKiR7bm90ZS5kZXNjcmlwdGlvbn0qXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyAtLS0gMy4gQ29tYmluZSBib3RoIHBhcnRzIGFuZCBjcmVhdGUgdGhlIGZpbGUgLS0tXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsUGxhbkNvbnRlbnQgPSByZXZpZXdDb250ZW50ICsgY2hlY2tsaXN0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1haW5Ub3BpYyA9IHBsYW5EYXRhLnBsYW5fZGV0YWlscy5tYWluX3RvcGljLnJlcGxhY2UoL1tcXFxcLzo/KlxcXCI8PnxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlUGhyYXNlID0gcGxhbkRhdGEucGxhbl9kZXRhaWxzLnVuaXF1ZV9waHJhc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYW5GaWxlTmFtZSA9IGAke21haW5Ub3BpY30gLSAke3VuaXF1ZVBocmFzZX0ubWRgO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGFuRmlsZVBhdGggPSBgJHt0aGlzLnNldHRpbmdzLnBsYW5zRm9sZGVyUGF0aH0vJHtwbGFuRmlsZU5hbWV9YDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKHRoaXMuc2V0dGluZ3MucGxhbnNGb2xkZXJQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKHRoaXMuc2V0dGluZ3MucGxhbnNGb2xkZXJQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShwbGFuRmlsZVBhdGgsIGZpbmFsUGxhbkNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nTWVzc2FnZSA9IGBDcmVhdGVkIG5vdGUgcGxhbiBmb3IgXCJbWyR7YWN0aXZlRmlsZS5wYXRofXwke2FjdGl2ZUZpbGUuYmFzZW5hbWV9XV1cIi4gTmV3IHBsYW4gaXMgYXQgXCJbWyR7cGxhbkZpbGVQYXRofXwke3BsYW5GaWxlTmFtZX1dXVwiLmA7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0VG9vbHMoKS5sb2dfYWN0aXZpdHkoe21lc3NhZ2U6IGxvZ01lc3NhZ2V9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFBsYW4gY3JlYXRlZCBzdWNjZXNzZnVsbHkhIEkndmUgY3JlYXRlZCBhIHBsYW4gZm9yIHlvdSBhdDogW1ske3BsYW5GaWxlUGF0aH18JHtwbGFuRmlsZU5hbWV9XV1gO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIG5vdGUgcGxhbjpcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0VG9vbHMoKS5sb2dfYWN0aXZpdHkoe21lc3NhZ2U6IGBFUlJPUjogRmFpbGVkIHRvIGNyZWF0ZSBub3RlIHBsYW4gZm9yIFwiW1ske2FjdGl2ZUZpbGUucGF0aH18JHthY3RpdmVGaWxlLmJhc2VuYW1lfV1dXCIuYH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTb3JyeSwgSSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhbmFseXppbmcgdGhlIG5vdGUuIFBsZWFzZSBjaGVjayB0aGUgY29uc29sZS5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZW5lcmF0ZV9ub3Rlc19mcm9tX3BsYW46IGFzeW5jICh7IHBsYW5fZmlsZV9wYXRoIH06IHsgcGxhbl9maWxlX3BhdGg/OiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwbGFuRmlsZTogVEZpbGUgfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChwbGFuX2ZpbGVfcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsYW5fZmlsZV9wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhbkZpbGUgPSBmaWxlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBFcnJvcjogUGxhbiBmaWxlIG5vdCBmb3VuZCBhdCBwYXRoIFwiJHtwbGFuX2ZpbGVfcGF0aH1cIi5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhbkZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBsYW5GaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogTm8gcGxhbiBmaWxlIHdhcyBwcm92aWRlZCwgYW5kIG5vIG5vdGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYW5Db250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChwbGFuRmlsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFza1JlZ2V4ID0gL14tIFxcWyBcXF0gXFwqXFwqKC4qPylcXCpcXCogXFxgXFwoKC4qPylcXClcXGBcXG5cXHMrLVxccypcXCooLio/KVxcKi9nbTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wb3NhbHMgPSBbLi4ucGxhbkNvbnRlbnQubWF0Y2hBbGwodGFza1JlZ2V4KV07XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcG9zYWxzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiTm8gcGVuZGluZyBub3RlcyB3aXRoIGRlc2NyaXB0aW9ucyBmb3VuZCBpbiB0aGUgcGxhbiBmaWxlLlwiO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBnZW5lcmF0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGdlbmVyYXRlZE5vdGVMaW5rcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wb3NhbCBvZiBwcm9wb3NhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBwcm9wb3NhbFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHByb3Bvc2FsWzJdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHByb3Bvc2FsWzNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wbGF0ZVBhdGggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXJDYXNlVHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTsgXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VyQ2FzZVR5cGUuaW5jbHVkZXMoJ21ham9yIGNvcmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQYXRoID0gYCR7dGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXNGb2xkZXJQYXRofS8wMiBNYWpvciBDb3JlIENvbmNlcHQgVGVtcGxhdGUubWRgO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZVR5cGUuaW5jbHVkZXMoJ2NvcmUnKSkgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUGF0aCA9IGAke3RoaXMuc2V0dGluZ3MudGVtcGxhdGVzRm9sZGVyUGF0aH0vMDMgQ29yZSBDb25jZXB0IFRlbXBsYXRlLm1kYDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb3dlckNhc2VUeXBlLmluY2x1ZGVzKCdwcm9jZXNzJykpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVBhdGggPSBgJHt0aGlzLnNldHRpbmdzLnRlbXBsYXRlc0ZvbGRlclBhdGh9LzAzIENvcmUgQ29uY2VwdCBUZW1wbGF0ZS5tZGA7IFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZVR5cGUuaW5jbHVkZXMoJ2Z1bmRhbWVudGFsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUGF0aCA9IGAke3RoaXMuc2V0dGluZ3MudGVtcGxhdGVzRm9sZGVyUGF0aH0vMDEgRnVuZGFtZW50YWwgQ29uY2VwdCBUZW1wbGF0ZS5tZGA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlVHlwZS5pbmNsdWRlcygncXVlc3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQYXRoID0gYCR7dGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXNGb2xkZXJQYXRofS8wNCBRdWVzdGlvbiBOb3RlIFRlbXBsYXRlLm1kYDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgTm8gdGVtcGxhdGUgZm91bmQgZm9yIHR5cGU6ICR7dHlwZX0uIFNraXBwaW5nIG5vdGU6ICR7dGl0bGV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdGVHZW5Qcm9tcHQgPSBgWW91IGFyZSBhbiBleHBlcnQga25vd2xlZGdlIGFyY2hpdGVjdC4gWW91ciB0YXNrIGlzIHRvIGdlbmVyYXRlIHRoZSBzdHJ1Y3R1cmVkIGNvbnRlbnQgZm9yIGFuIGF0b21pYyBub3RlLlxuICAgICAgICAgICAgICAgICAgICAqKlRpdGxlKio6IFwiJHt0aXRsZX1cIlxuICAgICAgICAgICAgICAgICAgICAqKlR5cGUqKjogXCIke3R5cGV9XCJcbiAgICAgICAgICAgICAgICAgICAgKipFc3NlbnRpYWwgQ29udGV4dCoqOiBUaGlzIG5vdGUgbXVzdCBiZSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHN1bW1hcnk6IFwiJHtjb250ZXh0fVwiLlxuXG4gICAgICAgICAgICAgICAgICAgIFBsZWFzZSByZXR1cm4gYSBzaW5nbGUsIHZhbGlkIEpTT04gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXlzLiBBZGhlcmUgc3RyaWN0bHkgdG8gdGhlIHR5cGVzIHJlcXVlc3RlZDpcbiAgICAgICAgICAgICAgICAgICAgLSBcInN1bW1hcnlfZGVmaW5pdGlvblwiOiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLSBcInN1bW1hcnlfYW5hbG9neVwiOiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLSBcImRldGFpbHNfYnVsbGV0c1wiOiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgIC0gXCJjb25uZWN0aW9uc19wYXJlbnRcIjogc3RyaW5nIChBIHNpbmdsZSB3aWtpbGluaywgZS5nLiwgW1tNTCAtIFN1cGVydmlzZWQgTGVhcm5pbmddXSlcbiAgICAgICAgICAgICAgICAgICAgLSBcImNvbm5lY3Rpb25zX2NoaWxkcmVuXCI6IGFycmF5IG9mIHN0cmluZ3MgKHdpa2lsaW5rcylcbiAgICAgICAgICAgICAgICAgICAgLSBcImNvbm5lY3Rpb25zX3JlbGF0ZWRcIjogYXJyYXkgb2Ygc3RyaW5ncyAoQ29udGV4dHVhbCBzZW50ZW5jZXMgd2l0aCB3aWtpbGlua3MpXG4gICAgICAgICAgICAgICAgICAgIC0gXCJxdWVzdGlvbnNcIjogYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAtIFwicmVsYXRlZF9saW5rc19mb3JfeWFtbFwiOiBhcnJheSBvZiBzdHJpbmdzIChBIGxpc3Qgb2YgVU5JUVVFIG5vdGUgdGl0bGVzIGZvciB0aGUgZnJvbnRtYXR0ZXIuICoqQ3J1Y2lhbGx5LCB0aGVzZSB0aXRsZXMgbXVzdCBhbHNvIGZvbGxvdyB0aGUgdXNlcidzIG5hbWluZyBjb252ZW50aW9ucywgZS5nLiwgXCJNTCAtIFVuc3VwZXJ2aXNlZCBMZWFybmluZ1wiKiopLlxuICAgICAgICAgICAgICAgICAgICBgO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5nZW5BSS5nZXRHZW5lcmF0aXZlTW9kZWwoeyBtb2RlbDogdGhpcy5zZXR0aW5ncy5tb2RlbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2RlbC5nZW5lcmF0ZUNvbnRlbnQobm90ZUdlblByb21wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uVGV4dCA9IHJlc3VsdC5yZXNwb25zZS50ZXh0KCkucmVwbGFjZSgvYGBganNvbi9nLCAnJykucmVwbGFjZSgvYGBgL2csICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhaUpzb24gPSBKU09OLnBhcnNlKGpzb25UZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKHRlbXBsYXRlUGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdFlhbWxMaXN0ID0gKGl0ZW1zOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCk6IHN0cmluZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcbicgKyBpdGVtcy5tYXAoaXRlbSA9PiBgICAtIFwiW1ske2l0ZW19XV1cImApLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsQ29udGVudCA9IHRlbXBsYXRlQ29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC97e1xccyp0aXRsZVxccyp9fS9naSwgdGl0bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLz4gX0Egc2ltcGxlLCBvbmUtc2VudGVuY2Ugc3VtbWFyeS4qXy9pLCBgPiAke2FpSnNvbi5zdW1tYXJ5X2RlZmluaXRpb24gfHwgJyd9YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvX0FuYWxvZ3k6IEEgaGVscGZ1bCwgcmVhbC13b3JsZCBhbmFsb2d5LipfL2ksIGBfJHthaUpzb24uc3VtbWFyeV9hbmFsb2d5IHx8ICcnfV9gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9fVGhlIGVzc2VudGlhbCBmYWN0cywgY2hhcmFjdGVyaXN0aWNzLCBvciBzdGVwcy4qXy9pLCAoYWlKc29uLmRldGFpbHNfYnVsbGV0cyB8fCBbXSkubWFwKChpdGVtOiBzdHJpbmcpID0+IGAtICR7aXRlbX1gKS5qb2luKCdcXG4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvVGhpcyBpcyBhIG1ham9yIGNvbXBvbmVudCBvZi4qL2ksIGBUaGlzIGlzIGEgbWFqb3IgY29tcG9uZW50IG9mICR7YWlKc29uLmNvbm5lY3Rpb25zX3BhcmVudCB8fCAnJ31gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8tXFxzKlxcW1xcW05hbWUgb2YgYSBjaGlsZCBDb3JlIElkZWEgbm90ZVxcXVxcXVxccyotXFxzKlxcW1xcW0Fub3RoZXIgY2hpbGQgQ29yZSBJZGVhIG5vdGVcXF1cXF0vaSwgKGFpSnNvbi5jb25uZWN0aW9uc19jaGlsZHJlbiB8fCBbXSkubWFwKChpdGVtOiBzdHJpbmcpID0+IGAtICR7aXRlbX1gKS5qb2luKCdcXG4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvLVxccypcXFtcXFtcXHMqXFxdXFxdL2ksIChhaUpzb24uY29ubmVjdGlvbnNfcmVsYXRlZCB8fCBbXSkubWFwKChpdGVtOiBzdHJpbmcpID0+IGAtICR7aXRlbX1gKS5qb2luKCdcXG4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvLVxccypcXD9cXHMqLVxccypcXD8vaSwgKGFpSnNvbi5xdWVzdGlvbnMgfHwgW10pLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgLSAke2l0ZW19YCkuam9pbignXFxuJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL3JlbGF0ZWQ6L2ksIGByZWxhdGVkOiR7Zm9ybWF0WWFtbExpc3QoYWlKc29uLnJlbGF0ZWRfbGlua3NfZm9yX3lhbWwpfWApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRUaXRsZSA9IHRpdGxlLnJlcGxhY2UoL1tcXFxcLzo/KlxcXCI8PnxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdGVGaWxlTmFtZSA9IGAke3Nhbml0aXplZFRpdGxlfS5tZGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RlRmlsZVBhdGggPSBgJHt0aGlzLnNldHRpbmdzLmRyYWZ0c0ZvbGRlclBhdGh9LyR7bm90ZUZpbGVOYW1lfWA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMobm90ZUZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShub3RlRmlsZVBhdGgsIGZpbmFsQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWROb3RlTGlua3MucHVzaChgW1ske25vdGVGaWxlUGF0aH18JHtub3RlRmlsZU5hbWV9XV1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgbm90ZSBmb3IgXCIke3RpdGxlfVwiOmAsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3IgZ2VuZXJhdGluZyBub3RlOiAke3RpdGxlfS4gQ2hlY2sgY29uc29sZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRlbnRlZExpc3QgPSBnZW5lcmF0ZWROb3RlTGlua3MubWFwKGxpbmsgPT4gYFxcblxcdC0gJHtsaW5rfWApLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ01lc3NhZ2UgPSBgR2VuZXJhdGVkICR7Z2VuZXJhdGVkQ291bnR9IG5vdGVzIGZyb20gcGxhbiBcIltbJHtwbGFuRmlsZS5wYXRofXwke3BsYW5GaWxlLmJhc2VuYW1lfV1dXCI6JHtpbmRlbnRlZExpc3R9YDtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldFRvb2xzKCkubG9nX2FjdGl2aXR5KHttZXNzYWdlOiBsb2dNZXNzYWdlfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQgJHtnZW5lcmF0ZWRDb3VudH0gbmV3IG5vdGVzIGluIHRoZSBkcmFmdHMgZm9sZGVyLmA7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGdldFRvb2xEZWNsYXJhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwibG9nX2FjdGl2aXR5XCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlY29yZHMgYSBtZXNzYWdlIHdpdGggYSB0aW1lc3RhbXAgdG8gYSBjZW50cmFsIGxvZyBmaWxlLiBVc2UgdGhpcyB0byByZXBvcnQgc3VjY2Vzc2Z1bCBhY3Rpb25zIG9yIGVycm9ycy5cIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogeyB0eXBlOiBcIk9CSkVDVFwiLCBwcm9wZXJ0aWVzOiB7IG1lc3NhZ2U6IHsgdHlwZTogXCJTVFJJTkdcIiwgZGVzY3JpcHRpb246IFwiVGhlIG1lc3NhZ2UgdG8gbG9nLlwiIH0gfSwgcmVxdWlyZWQ6IFtcIm1lc3NhZ2VcIl0gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJjcmVhdGVfbm90ZV9wbGFuXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlBoYXNlIDE6IFJlYWRzIHRoZSB1c2VyJ3MgY3VycmVudGx5IGFjdGl2ZSByYXcgbm90ZSwgYW5hbHl6ZXMgdGhlIGNvbnRlbnQgYW5kIG1hcmtlcnMgKE1DOiwgQzopLCBhbmQgY3JlYXRlcyBhIG5ldyAnUGxhbicgbm90ZSBjb250YWluaW5nIEFJIGZlZWRiYWNrLCBwcm9wb3NlZCBub3RlcyB3aXRoIHByb3BlciBuYW1pbmcgY29udmVudGlvbnMsIGFuZCBjb250ZXh0dWFsIGRlc2NyaXB0aW9ucyBmb3IgZWFjaC5cIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogeyB0eXBlOiBcIk9CSkVDVFwiLCBwcm9wZXJ0aWVzOiB7fSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImdlbmVyYXRlX25vdGVzX2Zyb21fcGxhblwiLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJQaGFzZSAyOiBHZW5lcmF0ZXMgbm90ZXMgZnJvbSBhIHBsYW4gZmlsZS4gSXQgdXNlcyB0aGUgY29udGV4dHVhbCBkZXNjcmlwdGlvbnMgaW4gdGhlIHBsYW4gdG8gY3JlYXRlIGhpZ2hseSByZWxldmFudCBhdG9taWMgbm90ZXMuIElmIGEgZmlsZSBwYXRoIGlzIHByb3ZpZGVkLCBpdCB1c2VzIHRoYXQgZmlsZS4gSWYgbm90LCBpdCBpbnRlbGxpZ2VudGx5IHVzZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgbm90ZSBhcyB0aGUgcGxhbi5cIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogeyB0eXBlOiBcIk9CSkVDVFwiLCBwcm9wZXJ0aWVzOiB7IHBsYW5fZmlsZV9wYXRoOiB7IHR5cGU6IFwiU1RSSU5HXCIsIGRlc2NyaXB0aW9uOiBcIlRoZSBvcHRpb25hbCBmdWxsIHBhdGggdG8gdGhlIHBsYW4gbm90ZSB0byBiZSBleGVjdXRlZC5cIiB9IH0gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJ1bih1c2VySW5wdXQ6IHN0cmluZywgdmlldzogQWdlbnRDaGF0Vmlldykge1xuICAgICAgICBpZiAoIXRoaXMuY2hhdCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hhdCkge1xuICAgICAgICAgICAgICAgIHZpZXcuYWRkTWVzc2FnZShcInN5c3RlbVwiLCBcIkFnZW50IG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIGNvbmZpZ3VyZSB5b3VyIEdlbWluaSBBUEkga2V5IGluIHNldHRpbmdzLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aGlua2luZ01lc3NhZ2UgPSB2aWV3LmFkZE1lc3NhZ2UoXCJtb2RlbFwiLCBcIlRoaW5raW5nLi4uXCIsIHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5jaGF0LnNlbmRNZXNzYWdlKHVzZXJJbnB1dCk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxscyA9IHJlc3VsdC5yZXNwb25zZS5mdW5jdGlvbkNhbGxzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvbkNhbGxzIHx8IGZ1bmN0aW9uQ2FsbHMubGVuZ3RoID09PSAwKSBicmVhazsgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbHMgPSB0aGlzLmdldFRvb2xzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChmdW5jdGlvbkNhbGxzLm1hcChhc3luYyAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sUmVzdWx0ID0gYXdhaXQgdG9vbHNbY2FsbC5uYW1lXShjYWxsLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmdW5jdGlvblJlc3BvbnNlOiB7IG5hbWU6IGNhbGwubmFtZSwgcmVzcG9uc2U6IHsgY29udGVudDogdG9vbFJlc3VsdCB9IH0gfTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmNoYXQuc2VuZE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkodG9vbFJlc3VsdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmlldy5yZW1vdmVUaGlua2luZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgIHZpZXcuYWRkTWVzc2FnZShcIm1vZGVsXCIsIHJlc3VsdC5yZXNwb25zZS50ZXh0KCkpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiR2VtaW5pIEFnZW50IEVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB2aWV3LnJlbW92ZVRoaW5raW5nTWVzc2FnZSgpO1xuICAgICAgICAgICAgdmlldy5hZGRNZXNzYWdlKFwic3lzdGVtXCIsIGBBbiBlcnJvciBvY2N1cnJlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8vIC0tLSBTRVRUSU5HUyBUQUIgQ0xBU1MgLS0tXG5cbmNsYXNzIEdlbWluaVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwbHVnaW46IE15UGx1Z2luO1xuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7IHN1cGVyKGFwcCwgcGx1Z2luKTsgdGhpcy5wbHVnaW4gPSBwbHVnaW47IH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIkdlbWluaSBBZ2VudCBTZXR0aW5nc1wiIH0pO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdHZW1pbmkgQVBJIEtleScpXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciBBUEkga2V5IGZvciB0aGUgR29vZ2xlIEdlbWluaSBBUEkuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIEFQSSBrZXknKS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5nZW1pbmlBcGlLZXkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmdlbWluaUFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5hZ2VudC5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC50eXBlID0gJ3Bhc3N3b3JkJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQUkgTW9kZWwgTmFtZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIEdlbWluaSBtb2RlbCB0byB1c2UgZm9yIHRoZSBhZ2VudC4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuLCBnZW1pbmktMS41LXByby1sYXRlc3QnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tb2RlbClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1vZGVsID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRHJhZnRzIEZvbGRlciBQYXRoJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdGb2xkZXIgZm9yIG5ld2x5IGdlbmVyYXRlZCBhdG9taWMgbm90ZXMgYW5kIHRoZSBsb2cgZmlsZS4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFeGFtcGxlOiBHZW1pbmkgRHJhZnRzJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZHJhZnRzRm9sZGVyUGF0aClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRyYWZ0c0ZvbGRlclBhdGggPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUGxhbnMgRm9sZGVyIFBhdGgnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0ZvbGRlciBmb3IgdGhlIGdlbmVyYXRlZCByZXZpZXcgYW5kIHBsYW4gbm90ZXMuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRXhhbXBsZTogR2VtaW5pIFBsYW5zJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucGxhbnNGb2xkZXJQYXRoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGxhbnNGb2xkZXJQYXRoID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1RlbXBsYXRlcyBGb2xkZXIgUGF0aCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnUGF0aCB0byB0aGUgZm9sZGVyIGNvbnRhaW5pbmcgeW91ciBub3RlIHRlbXBsYXRlcy4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFeGFtcGxlOiAwMCBJbmJveC8wMCBUZW1wbGF0ZXMnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy50ZW1wbGF0ZXNGb2xkZXJQYXRoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudGVtcGxhdGVzRm9sZGVyUGF0aCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxufVxuXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
